{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Classes and Methods in R\"\nauthor: \"The Johns Hopkins Data Science Lab\"\noutput: pdf_document\nalways_allow_html: yes\n---\n\n## Classes and Methods\n\n- A system for doing object oriented programming\n- R was originally quite interesting because it is both interactive _and_ has a system for object orientation.\n    - Other languages which support OOP (C++, Java, Lisp, Python, Perl) generally speaking are not interactive languages\n    \n## Classes and Methods\n\n- In R much of the code for supporting classes/methods is written by John Chambers himself (the creator of the original S language) and documented in the book _Programming with Data: A Guide to the S Language_\n- A natural extension of Chambers' idea of allowing someone to cross the user -> programmer spectrum\n- Object oriented programming is a bit different in R than it is in most languages - even if you are familiar with the idea, you may want to pay attention to the details\n\n## Two styles of classes and methods\n\nS3 classes/methods\n- Included with version 3 of the S language. \n- Informal, a little kludgey\n- Sometimes called _old-style_ classes/methods\n\nS4 classes/methods\n- more formal and rigorous\n- Included with S-PLUS 6 and R 1.4.0 (December 2001) \n- Also called _new-style_ classes/methods\n\n## Two worlds living side by side\n\n- For now (and the forseeable future), S3 classes/methods and S4 classes/methods are separate systems (but they can be mixed to some degree).\n- Each system can be used fairly independently of the other.\n- Developers of new projects (you!) are encouraged to use the S4 style classes/methods.\n    - Used extensively in the Bioconductor project\n- But many developers still use S3 classes/methods because they are \"quick and dirty\" (and easier).\n- In this lecture we will focus primarily on S4 classes/methods\n- The code for implementing S4 classes/methods in R is in the *methods* package, which is usually loaded by default (but you can load it with `library(methods)` if for some reason it is not loaded)\n\n## Object Oriented Programming in R\n\n- A class is a description of a thing. A class can be defined using `setClass()` in the *methods* package.\n- An _object_ is an instance of a class. Objects can be created using `new()`. \n- A _method_ is a function that only operates on a certain class of objects.\n- A generic function is an R function which dispatches methods. A generic function typically encapsulates a \"generic\" concept (e.g. `plot`, `mean`, `predict`, ...)\n    - The generic function does not actually do any computation.\n- A _method_ is the implementation of a generic function for an object of a particular class.\n\n## Things to look up\n\n- The help files for the 'methods' package are extensive - do read them as they are the primary documentation\n- You may want to start with `?Classes` and `?Methods` \n- Check out `?setClass`, `?setMethod`, and `?setGeneric`\n- Some of it gets technical, but try your best for now-it will make sense in the future as you keep using it.\n- Most of the documentation in the *methods* package is oriented towards developers/programmers as these are the primary people using classes/methods\n\n## Classes\n\nAll objects in R have a class which can be determined by the class function\n\n```{r}\nclass(1)\nclass(TRUE)\n```\n\n## Classes\n\n```{r}\nclass(rnorm(100))\nclass(NA)\nclass(\"foo\")\n```\n\n## Classes (cont'd)\n\nData classes go beyond the atomic classes\n\n```{r}\nx <- rnorm(100)\ny <- x + rnorm(100)\nfit <- lm(y ~ x)  ## linear regression model\nclass(fit)\n```\n\n## Generics/Methods in R\n\n- S4 and S3 style generic functions look different but conceptually, they are the same (they play the same role).\n- When you program you can write new methods for an existing generic OR create your own generics and associated methods.\n- Of course, if a data type does not exist in R that matches your needs, you can always define a new class along with generics/methods that go with it.\n\n## An S3 generic function (in the 'base' package)\n\nThe `mean` and `print` functions are generic \n```{r}\nmean\n```\n\n## An S3 generic function (in the 'base' package)\n\n```{r}\nprint\n```\n\n## S3 methods\n\nThe `mean` generic function has a number of methods associated with it.\n\n```{r}\nmethods(\"mean\")\n```\n\n## An S4 generic function\n\nThe `show` function is from the <b>methods</b> package and is the S4\nequivalent of `print`\n```{r}\nlibrary(methods)\nshow\n```\nThe `show` function is usually not called directly (much like `print`)\nbecause objects are auto-printed.\n\n## S4 methods\n\n```{r}\nshowMethods(\"show\")\n```\n\n## Generic/method mechanism\n\nThe first argument of a generic function is an object of a particular class (there may be other arguments)\n\n1. The generic function checks the class of the object.\n2. A search is done to see if there is an appropriate method for that class.\n3. If there exists a method for that class, then that method is called on the object and we're done.\n4. If a method for that class does not exist, a search is done to see if there is a default method for the generic. If a default exists, then the default method is called.\n5. If a default method doesn't exist, then an error is thrown.\n\n## Examining Code for Methods\n\n- You cannot just print the code for a method like other functions because the code for the method is usually hidden.\n- If you want to see the code for an S3 method, you can use the function `getS3method`.\n- The call is `getS3method(<generic>, <class>)`\n- For S4 methods you can use the function `getMethod`\n- The call is `getMethod(<generic>, <signature>)` (more details later)\n\n## S3 Class/Method: Example 1\n\nWhat's happening here?\n\n```{r}\nset.seed(2)\nx <- rnorm(100)\nmean(x)\n```\n\n1. The class of x is \"numeric\"\n2. But there is no mean method for \"numeric\" objects!\n3. So we call the default function for `mean`.\n\n## S3 Class/Method: Example 1\n\n```{r}\nhead(getS3method(\"mean\", \"default\"), 10)\n```\n\n## S3 Class/Method: Example 1\n\n```{r}\ntail(getS3method(\"mean\", \"default\"), 10)\n```\n\n## S3 Class/Method: Example 2\n\nWhat happens here?\n\n```{r}\nset.seed(3)\ndf <- data.frame(x = rnorm(100), y = 1:100)\nsapply(df, mean)\n```\n\n## S3 Class/Method: Example 2\n\n1. The class of `df` is \"data.frame\"; each column can be an object of\na different class\n\n2. We `sapply` over the columns and call the `mean` function\n\n3. In each column, `mean` checks the class of the object and dispatches the\nappropriate method.\n\n4. We have a `numeric` column and an `integer` column; `mean` calls the default method for both\n\n## Calling Methods Directly\n\n* Some S3 methods are visible to the user (i.e. `mean.default`),\n\n* <b>Never</b> call methods directly\n\n* Use the generic function and let the method be dispatched\nautomatically.\n\n* With S4 methods you cannot call them directly at all\n\n## S3 Class/Method: Example 3\n\nThe `plot` function is generic and its behavior depends on the object being plotted. \n\n```{r ex3_1,eval=FALSE}\nset.seed(10)\nx <- rnorm(100)\nplot(x)\n```\n\n## S3 Class/Method: Example 3\n\n```{r tenPlot, echo=FALSE}\nset.seed(10)\nx <- rnorm(100)\nplot(x)\n```\n\n## S3 Class/Method: Example 3\n\nFor time series objects, `plot` connects the dots\n\n```{r ex3_3,eval=FALSE}\nset.seed(10)\nx <- rnorm(100)\nx <- as.ts(x) ## Convert to a time series object \nplot(x)\n```\n\n## S3 Class/Method: Example 3\n\n```{r ex3_4,echo=FALSE}\nset.seed(10)\nx <- rnorm(100)\nx <- as.ts(x) ## Convert to a time series object \nplot(x)\n```\n\n## Write your own methods!\n\nIf you write new methods for new classes, you'll probably end up writing methods for the following generics:\n- print/show \n- summary \n- plot\n\nThere are two ways that you can extend the R system via classes/methods\n- Write a method for a new class but for an existing generic function (i.e. like\n`print`)\n- Write new generic functions and new methods for those generics\n\n## S4 Classes\n\nWhy would you want to create a new class?\n- To represent new types of data (e.g. gene expression, space-time, hierarchical, sparse matrices)\n- New concepts/ideas that haven't been thought of yet (e.g. a fitted point process model, mixed-effects model, a sparse matrix)\n- To abstract/hide implementation details from the user\nI say things are \"new\" meaning that R does not know about them (not that they are new to the statistical community).\n\n## S4 Class/Method: Creating a New Class\n\nA new class can be defined using the `setClass` function\n- At a minimum you need to specify the name of the class\n- You can also specify data elements that are called _slots_\n- You can then define methods for the class with the `setMethod` function \n- Information about a class definition can be obtained with the `showClass` function\n\n## S4 Class/Method: Polygon Class\n\nCreating new classes/methods is usually not something done at the console; you likely want to save the code in a separate file\n\n```{r polygon_1, tidy = FALSE}\nlibrary(methods)\nsetClass(\"polygon\",\n         representation(x = \"numeric\",\n                        y = \"numeric\"))\n```\n\n- The slots for this class are `x` and `y`\n\n- The slots for an S4 object can be accessed with the `@` operator.\n\n## S4 Class/Method: Polygon Class\n\nA plot method can be created with the `setMethod` function.\n\n- For `setMethod` you need to specify a generic function (`plot`), and\n  a _signature_.\n\n- A signature is a character vector indicating the classes of objects\n  that are accepted by the method.\n\n- In this case, the `plot` method will take one type of object, a\n  `polygon` object.\n\n## S4 Class/Method: Polygon Class\n\nCreating a `plot` method with `setMethod`.\n\n```{r polygon_2, tidy = FALSE}\nsetMethod(\"plot\", \"polygon\",\n          function(x, y, ...) {\n                  plot(x@x, x@y, type = \"n\", ...)\n                  xp <- c(x@x, x@x[1])\n                  yp <- c(x@y, x@y[1])\n                  lines(xp, yp)\n\t  })\n```\n\n- Notice that the slots of the polygon (the x- and y-coordinates) are\n  accessed with the `@` operator.\n\n## S4 Class/Method: Polygon Class\n\nAfter calling `setMethod` the new `plot` method will be added to the list of methods for `plot`.\n\n```{r polygon_3}\nlibrary(methods)\nshowMethods(\"plot\")\n```\n\nNotice that the signature for class `polygon` is listed. The method for `ANY` is the default method and it is what is called when now other signature matches\n\n## S4 Class/Method: Polygon class\n\n```{r polygon_4}\np <- new(\"polygon\", x = c(1, 2, 3, 4), y = c(1, 2, 3, 1))\nplot(p)\n```\n\n## Summary\n\n- Developing classes and associated methods is a powerful way to\n  extend the functionality of R\n\n- <b>Classes</b> define new data types\n\n- <b>Methods</b> extend <b>generic functions</b> to specify the behavior\n    of generic functions on new classes\n\n- As new data types and concepts are created, classes/methods provide\n  a way for you to develop an intuitive interface to those\n  data/concepts for users\n\n## Where to Look, Places to Start\n\n- The best way to learn this stuff is to look at examples\n\n- There are quite a few examples on CRAN which use S4\n  classes/methods. You can usually tell if they use S4 classes/methods\n  if the <b>methods</b> package is listed in the `Depends:` field\n\n- Bioconductor (http://www.bioconductor.org) - a rich resource, even\n  if you know nothing about bioinformatics\n\n- Some packages on CRAN (as far as I know) - SparseM, gpclib, flexmix,\n  its, lme4, orientlib, filehash\n\n- The `stats4` package (comes with R) has a bunch of classes/methods\nfor doing maximum likelihood analysis.\n\n",
    "created" : 1513861637365.000,
    "dirty" : false,
    "encoding" : "ISO-8859-1",
    "folds" : "",
    "hash" : "2388199606",
    "id" : "7B16C188",
    "lastKnownWriteTime" : 1513843231,
    "last_content_update" : 1513843231,
    "path" : "~/Google Drive/Coursera/Data scientist/repos/Developing_Data_Products/Classes_and_Methods/Classes_and_Methods.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}