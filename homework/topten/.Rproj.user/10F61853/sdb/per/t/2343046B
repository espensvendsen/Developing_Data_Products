{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Data_products_week_3\"\nauthor: \"Espen Svendsen\"\ndate: \"21 12 2017\"\noutput: html_document\n---\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n- PART 1: R packages\n- PART 2: R classes and methods\n\n\n# R packages (Part 1)\n## What is an R Package?\n\nAn R Package is a form of DATA PRODUCT. In creating an R package, you've created polished, documented software for your users.\n\n- A mechanism for extending the basic functionality of R\n- A collection of R functions, or other (data) objects\n- Organized in a systematic fashion to provide a minimal amount of consistency\n- Written by users/developers everywhere\n\n\n\n## Where are These R Packages?\n\n- Primarily available from CRAN and Bioconductor\n- Also available from GitHub, Bitbucket, Gitorious, etc. (and elsewhere)\n- Packages from CRAN/Bioconductor can be installed with `install.packages()`\n- Packages from GitHub can be installed using `install_github()` from\n  the <b>devtools</b> package\n  \nYou do not have to put a package on a central repository, but doing so\nmakes it easier for others to install your package.\n\n## What's the Point?\n\n- \"Why not just make some code available?\"\n- Documentation / vignettes\n- Centralized resources like CRAN\n- Minimal standards for reliability and robustness\n- Maintainability / extension\n- Interface definition / clear API\n- Users know that it will at least load properly\n\n## Package Development Process\n\n- Write some code in an R script file (.R)\n- Want to make code available to others\n- Incorporate R script file into R package structure\n- Write documentation for user functions\n- Include some other material (examples, demos, datasets, tutorials)\n- Package it up!\n\n- Submit package to CRAN or Bioconductor\n- Push source code repository to GitHub or other source code sharing web site\n- People find all kinds of problems with your code\n  - Scenario #1: They tell you about those problems and expect you to fix it\n  - Scenario #2: They fix the problem for you and show you the changes\n- You incorporate the changes and release a new version\n\n\n# R packages (Part 2)\n## R Package Essentials\n- DIRECTORY with the name of the R package\n- DESCRIPTION file which has info about the package\n- R/source_files\n- man/documentation_files\n- /NAMESPACE\n\nThere are more: Full requirements in Writing R Extensions\n\n## The DESCRIPTION File (mand.)\n- <b>Package</b>: Name of package (e.g. library(name))\n- <b>Title</b>: Full name of package\n- <b>Description</b>: Longer description of package in one sentence (usually)\n- <b>Version</b>: Version number (usually M.m-p format)\n- <b>Author</b>, <b>Authors@R</b>: Name of the original author(s)\n- <b>Maintainer</b>: Name + email of person who fixes problems\n- <b>License</b>: License for the source code\n\n## The DESCRIPTION File (opt.)\n- <b>Depends</b>: R packages that your package depends on\n- <b>Suggests</b>: Optional R packages that users may want to have installed\n- <b>Date</b>: Release date in YYYY-MM-DD format\n- <b>URL</b>: Package home page\n- <b>Other</b> fields can be added\n\n## DESCRIPTION File (example): `gpclib`\n<b>Package</b>:  gpclib<br />\n<b>Title</b>:  General Polygon Clipping Library for R<br />\n<b>Description</b>:  General polygon clipping routines for R based on Alan Murta's C library.<br />\n<b>Version</b>:  1.5-5<br />\n<b>Author</b>:  Roger D. Peng <rpeng@jhsph.edu> with contributions from Duncan Murdoch and Barry Rowlingson; GPC library by Alan Murta<br />\n<b>Maintainer</b>:  Roger D. Peng <rpeng@jhsph.edu><br />\n<b>License</b>:  file LICENSE<br />\n<b>Depends</b>:  R (>= 2.14.0), methods<br />\n<b>Imports</b>:  graphics<br />\n<b>Date</b>:  2013-04-01<br />\n<b>URL</b>:  http://www.cs.man.ac.uk/~toby/gpc/, http://github.com/rdpeng/gpclib\n\n## /R\n- There can be any number of files in this directory\n- Usually separate out files into logical groups\n- Code for all functions should be included here and not anywhere else in the package\n\n## The NAMESPACE File (EXPORT)\n- Used to indicate which functions are EXPORTED (public)\n- Exported functions can be called by the user and are considered the public API\n- Non-exported functions cannot be called directly by the user (but the code can be viewed)\n- Hides implementation details from users and makes a cleaner package interface\n\n## The NAMESPACE File (IMPORT)\n- You can also indicate what functions you IMPORT from other packages\n- This allows for your package to use other packages WITHOUT MAKING OTHER PACKES VISIBLE to the user\n- Importing a function loads the package but does not attach it to the search list\nWHAT THE FUCK IS THE SEARCH LIST?\n\n## The NAMESPACE File (layout)\nKey directives\n- export(\"\\<function>\") \n- import(\"\\<package>\")\n- importFrom(\"\\<package>\", \"\\<function>\")\n\nAlso important\n- exportClasses(\"\\<class>\")\n- exportMethods(\"\\<generic>\")\n\n## NAMESPACE File: `mvtsplot` package\n```r\nexport(\"mvtsplot\")\nimport(splines)\nimport(RColorBrewer)\nimportFrom(\"grDevices\", \"colorRampPalette\", \"gray\")\nimportFrom(\"graphics\", \"abline\", \"axis\", \"box\", \"image\", \n           \"layout\", \"lines\", \"par\", \"plot\", \"points\", \n           \"segments\", \"strwidth\", \"text\", \"Axis\")\nimportFrom(\"stats\", \"complete.cases\", \"lm\", \"na.exclude\", \n           \"predict\", \"quantile\")\n```\n\n## NAMESPACE File: `gpclib` package\n```r\nexport(\"read.polyfile\", \"write.polyfile\")\n\nimportFrom(graphics, plot)\n\nexportClasses(\"gpc.poly\", \"gpc.poly.nohole\")\n# NOTE: HERE YOU PROBABLY RESTRICT WHAT YOU MAY INSERT (SEARCH LIST)\nexportMethods(\"show\", \"get.bbox\", \"plot\", \"intersect\", \"union\", \n              \"setdiff\", \"[\", \"append.poly\", \"scale.poly\", \n              \"area.poly\", \"get.pts\", \"coerce\", \"tristrip\", \n              \"triangulate\")\n```\n\n## /man\n- Documentation files (.Rd) \n- Written in a specific markup language\n- Required for every exported function\n  - Another reason to limit exported functions\n- You can document other things like concepts, package overview\n\n## Help File Example: `line` Function\n```\n\\name{line}\n\\alias{line}\n\\alias{residuals.tukeyline}\n\\title{Robust Line Fitting}\n\\description{\n  Fit a line robustly as recommended in \\emph{Exploratory Data Analysis}.\n}\n\\usage{\nline(x, y)\n}\n\\arguments{\n  \\item{x, y}{the arguments can be any way of specifying x-y pairs.  See\n    \\code{\\link{xy.coords}}.}\n}\n\\details{\n  Cases with missing values are omitted.\n\n  Long vectors are not supported.\n}\n\\value{\n  An object of class \\code{\"tukeyline\"}.\n\n  Methods are available for the generic functions \\code{coef},\n  \\code{residuals}, \\code{fitted}, and \\code{print}.\n}\n\\references{\n  Tukey, J. W. (1977).\n  \\emph{Exploratory Data Analysis},\n  Reading Massachusetts: Addison-Wesley.\n}\n```\n\n## Building and Checking\n- R CMD build is a command-line program that creates a package archive\n  file (`.tar.gz`)\n- R CMD check runs a battery of tests on the package\n- You can run R CMD build or R CMD check from the command-line using a\n  terminal or command-shell application\n- You can also run them from R using the system() function\n```r\nsystem(\"R CMD build newpackage\")\nsystem(\"R CMD check newpackage\")\n```\n\n## Checking - R CMD check\n- Documentation exists\n- Code can be loaded, no major coding problems or errors\n- Run examples in documentation\n- Check docs match code\n- All tests must pass to put package on CRAN\n\n\n## Getting Started - package.skeleton()\n- The `package.skeleton()` function in the utils package creates a \"skeleton\" R package\n- Directory structure (R/, man/), DESCRIPTION file, NAMESPACE file, documentation files\n- If there are functions visible in your workspace, it writes R code files to the R/ directory\n  THIS IS SUPER USEFUL, BUT REQUIRES A CLEAN WORKSPACE BEFORE INVOKING package.skeleton()\n- Documentation stubs are created in man/\n- You need to fill in the rest!\n\n## Summary - CHECKLIST FOR BUILDING R PACKAGES\n- Create a new directory with R/ and man/ sub-directories (or just use package.skeleton())\n- Write a DESCRIPTION file\n- Copy R code into the R/ sub-directory\n- Write documentation files in man/ sub-directory\n- Write a NAMESPACE file with exports/imports\n- Build and check\n--------------------------------------------\n\n# R classes and methods (Part 1)\n\n## Classes and Methods (type system? OOP)\n- A system for doing object oriented programming \n  CROSSING THE BOUNDARY FROM USERS TO PROGRAMMER\n- R was originally quite interesting because it is both interactive _and_ has a system for object orientation.\n    - Other languages which support OOP (C++, Java, Lisp, Python, Perl) generally speaking are not interactive languages\n\n## Two styles of classes and methods\nS3 classes/methods\n- Included with version 3 of the S language. \n- Informal, a little kludgey\n- Sometimes called _old-style_ classes/methods\nS4 classes/methods\n- more formal and rigorous\n- Included with S-PLUS 6 and R 1.4.0 (December 2001) \n- Also called _new-style_ classes/methods\n\n## Object Oriented Programming in R - classes\n- `setClass()` in the *methods* package.\n- A class is a description of a thing. A class can be defined using `setClass()` in the *methods* package.\n- An _object_ is an instance of a class. Objects can be created using `new()`. \n- A _method_ is a function that only operates on a certain class of objects.\n\n## Object Oriented Programming in R - generic functions\nGeneric function means a static function, without any object instance attached to it.\nIt performs a kind of polymorphic dispatch of method execution\n\nS4:\ngenFunc(myObject) { //of type MyClass\n    myOject.genFunc(x, y) { // polymorphic dispatch\n       genFunc(x, y) // common to reuse default generic function\n       // some extra manipulations for MyClass\n       // ...\n    }\n}\n\nS3:\ngenFunc.default(x) { // applies to any type, unless asserted for type, values, etc\n    doSomething(x.getProperty1(), ....)\n}\ngenFunc.MyClass(myObject) { //of type MyClass, SHOULD NEVER BE USED. genFunc.default(x) WILL FIND THE CORRECT DISPATCH\n    doSomething(myObject.getProperty1(), ....)\n}\n- A generic function is an R function which DISPATCHES methods. A generic function typically encapsulates a \"generic\" concept (e.g. `plot`, `mean`, `predict`, ...) \n- The generic function does not actually do any computation, but \n- A _method_ is the implementation of a GENERIC function for an object of a particular class.\n\n## Classes - all objects in R have a class\nATOMIC CLASSES\n```{r}\nclass(1)\nclass(TRUE)\nclass(rnorm(100))\nclass(NA)\nclass(\"foo\")\n```\n\n## Classes - NON-ATOMIC\n```{r}\nx <- rnorm(100)\ny <- x + rnorm(100)\nfit <- lm(y ~ x)\nclass(fit) # lm class\n```\n\n## Generics/Methods in R\n- S4 and S3 style generic functions look different but conceptually, they are the same (they play the same role).\n- When you program you can write new methods for an existing generic OR create your own generics and associated methods.\n- Of course, if a data type does not exist in R that matches your needs, you can always define a new class along with generics/methods that go with it.\n- \"THEIR JOB IS TO FIND AN APPROPRIATE METHOD FOR WHATEVER DATA TYPE BEING PASSED TO THEM\"\n\n## An S3 generic function (in the 'base' package)\nThe `mean` and `print` functions are generic \n```{r}\nmean\nprint\n```\n\n## S3 methods\nThe `mean` generic function has a number of methods associated with it.\n```{r}\nmethods(\"mean\")\n```\n\n## An S4 generic function\n\nThe `show` function is from the <b>methods</b> package and is the S4\nequivalent of `print`\n```{r}\nlibrary(methods)\nshow\nshowMethods(\"show\") # Much cleaner than S3 (old school), which require specific generic method for overloading\n```\n\n## Generic/method mechanism\nThe first argument of a generic function is an object of a particular class (there may be other arguments)\n1. The generic function checks the class of the object.\n2. A search is done to see if there is an appropriate method for that class.\n3. If there exists a method for that class, then that method is called on the object and we're done.\n4. If a method for that class does not exist, a search is done to see if there is a default method for the generic. If a default exists, then the default method is called.\n5. If a default method doesn't exist, then an error is thrown.\n\n## Examining Code for Methods\n- You cannot just print the code for a method like other functions because the code for the method is usually hidden.\n- If you want to see the code for an S3 method, you can use the function `getS3method`.\n- The call is `getS3method(<generic>, <class>)`\n- For S4 methods you can use the function `getMethod`\n- The call is `getMethod(<generic>, <signature>)` (more details later)\n--------------------------------\n\n# R classes and methods (Part 2)\n\n## S3 Class/Method: Example 1\nWhat's happening here?\n```{r}\nset.seed(2)\nx <- rnorm(100)\nmean(x)\n```\n1. The class of x is \"numeric\"\n2. But there is no mean method for \"numeric\" objects!\n3. So we call the default function for `mean`.\n\n## S3 Class/Method: Example 1\n\n```{r}\ngetS3method(\"mean\", \"default\")\n```\n\n## S3 Class/Method: Example 2\n```{r}\nset.seed(3)\ndf <- data.frame(x = rnorm(100), y = 1:100)\ntmp <- sapply(df, mean)\n```\n\n## S3 Class/Method: Example 2\n1. The class of `df` is \"data.frame\"; each column can be an object of\na different class\n2. We `sapply` over the columns and call the `mean` function\n3. In each column, `mean` checks the class of the object and dispatches the\nappropriate method.\n4. We have a `numeric` column and an `integer` column; `mean` calls the default method for both\n\n## Calling Methods Directly - NEVER\n* Some S3 methods are visible to the user (i.e. `mean.default`),\n* <b>Never</b> call methods directly\n* Use the generic function and let the method be dispatched\nautomatically.\n* With S4 methods you cannot call them directly at all\n\n## S3 Class/Method: Example 3\n\nThe `plot` function is generic and its behavior depends on the object being plotted. \n```{r ex3_1,eval=FALSE}\nset.seed(10)\nx <- rnorm(100)\nplot(x)\n```\n## S3 Class/Method: Example 3\nFor time series objects, `plot` connects the dots\n```{r ex3_3,eval=FALSE}\nset.seed(10)\nx <- rnorm(100)\nx <- as.ts(x) ## Convert to a time series object \nplot(x)\n```\n\n## Write your own methods! NEW TYPES SHOULD HAVE PRINT/SHOW, SUMMARY, PLOT (like Java tostring())\nIf you write new methods for new classes, you'll probably end up writing methods for the following generics:\n- print/show \n- summary \n- plot\n\nThere are two ways that you can extend the R system via classes/methods\n- Write a method for a new class but for an existing generic function (i.e. like\n`print`)\n- Write new generic functions and new methods for those generics\n\n## S4 Classes\nWhy would you want to create a new class?\n- To represent new types of data (e.g. gene expression, space-time, hierarchical, sparse matrices)\n- New concepts/ideas that haven't been thought of yet (e.g. a fitted point process model, mixed-effects model, a sparse matrix)\n- To abstract/hide implementation details from the user\nI say things are \"new\" meaning that R does not know about them (not that they are new to the statistical community).\n\n## S4 Class/Method: Creating a New Class\nA new class can be defined using the `setClass` function\n- NAME: At a minimum you need to specify the name of the class\n- SLOTS: You can also specify data elements that are called _slots_\n- METHODS: You can then define methods for the class with the `setMethod` function \n- Information about a class definition can be obtained with the `showClass` function\n\n## S4 Class/Method: Polygon Class\nCreating new classes/methods is usually not something done at the console; you likely want to save the code in a separate file\n```{r polygon_1, tidy = FALSE}\nlibrary(methods)\nsetClass(\"polygon\",\n         representation(x = \"numeric\",\n                        y = \"numeric\"))\n```\n- The slots for this class are `x` and `y`\n- The slots for an S4 object can be accessed with the `@` operator.\n\n## S4 Class/Method: Polygon Class\nA plot method can be created with the `setMethod` function.\n- For `setMethod` you need to specify a generic function (`plot`), and\n  a _signature_.\n- A signature is a character vector indicating the classes of objects\n  that are accepted by the method.\n- In this case, the `plot` method will take one type of object, a\n  `polygon` object.\n\n## S4 Class/Method: Polygon Class\n\nCreating a `plot` method with `setMethod`.\n\n```{r polygon_2, tidy = FALSE}\nsetMethod(\"plot\", \"polygon\",\n          function(x, y, ...) {\n                  plot(x@x, x@y, type = \"n\", ...)\n                  xp <- c(x@x, x@x[1])\n                  yp <- c(x@y, x@y[1])\n                  lines(xp, yp)\n\t  })\n```\n\n- Notice that the slots of the polygon (the x- and y-coordinates) are\n  accessed with the `@` operator.\n\n## S4 Class/Method: Polygon Class\n\nAfter calling `setMethod` the new `plot` method will be added to the list of methods for `plot`.\n\n```{r polygon_3}\nlibrary(methods)\nshowMethods(\"plot\")\n```\n\nNotice that the signature for class `polygon` is listed. The method for `ANY` is the default method and it is what is called when now other signature matches\n\n## S4 Class/Method: Polygon class\n\n```{r polygon_4}\np <- new(\"polygon\", x = c(1, 2, 3, 4), y = c(1, 2, 3, 1))\nplot(p)\n```\n\n## Summary\n\n- Developing classes and associated methods is a powerful way to\n  extend the functionality of R\n\n- <b>Classes</b> define new data types\n\n- <b>Methods</b> extend <b>generic functions</b> to specify the behavior\n    of generic functions on new classes\n\n- As new data types and concepts are created, classes/methods provide\n  a way for you to develop an intuitive interface to those\n  data/concepts for users\n\n## Where to Look, Places to Start\n\n- The best way to learn this stuff is to look at examples\n\n- There are quite a few examples on CRAN which use S4\n  classes/methods. You can usually tell if they use S4 classes/methods\n  if the <b>methods</b> package is listed in the `Depends:` field\n\n- Bioconductor (http://www.bioconductor.org) - a rich resource, even\n  if you know nothing about bioinformatics\n\n- Some packages on CRAN (as far as I know) - SparseM, gpclib, flexmix,\n  its, lme4, orientlib, filehash\n\n- The `stats4` package (comes with R) has a bunch of classes/methods\nfor doing maximum likelihood analysis.\n\n",
    "created" : 1513861676928.000,
    "dirty" : false,
    "encoding" : "ISO-8859-1",
    "folds" : "",
    "hash" : "3577635785",
    "id" : "2343046B",
    "lastKnownWriteTime" : 1513867902,
    "last_content_update" : 1513868113423,
    "path" : "~/Google Drive/Coursera/Data scientist/Data_products/Data_products_week_3.Rmd",
    "project_path" : null,
    "properties" : {
        "last_setup_crc32" : "BF09A510bb338d19"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}